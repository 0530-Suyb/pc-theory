[toc]

## 基础性能测试

### 实验环境

| 硬件 | 性能                                                   |
| ---- | ------------------------------------------------------ |
| CPU  | Inter i7-10700 8核16线程 基本频率2.9Ghz 最大睿频4.8Ghz |
| 内存 | 16GiB                                                  |
| 硬盘 | 512GB                                                  |

| 软件           | 版本    |
| -------------- | ------- |
| ubuntu         | 20.04   |
| caliper        | 0.5     |
| docker         | 24.0.5  |
| docker-compose | 1.25.0  |
| Fabric         | v2.2.14 |
| PC-Fabric      |         |
| PC-P3Chain     |         |



### 实验设置

#### Fabric/PC-Fabric

对照组设置：

- 单池单合约：Fabric vs PC-Fabric（原Fabric相当于单池）
- PC-Fabric自对比：单池单合约 vs 3池1合约（合约只发往一个池） vs 3池3合约（各池各1个合约，各个合约的具体函数都是set和get两种）

| 自变量          | 参数                                                         |
| --------------- | ------------------------------------------------------------ |
| 网络拓扑        | 2 peer（不同组织）、3 orderer（raft）                        |
| 交易类型        | set、get                                                     |
| 发送TPS         | 100 - 1000 （各次测试总交易量10000）                         |
| orderer共识配置 | 交易最多等待时间1s、单笔交易最大大小99MB、单个区块最多交易数300、单个区块所有交易最大总大小512k（实际上每笔交易只需有一个peer背书，单笔交易大小约3k，实际上单个区块约170笔交易） |

#### PC-P3Chain

- PC-P3Chain自对比：单池单合约 vs 3池1合约（合约只发往一个池） vs 3池3合约（各池各1个合约，各个合约的具体函数都是set和get两种）

| 自变量   | 参数                                 |
| -------- | ------------------------------------ |
| 网络拓扑 | 4 dper（并发PBFT）                   |
| 交易类型 | set、get                             |
| 发送TPS  | 100 - 1000 （各次测试总交易量10000） |
| 共识配置 | 定时200ms打包，无提前执行交易        |



### 实验结果

#### TPS：Fabric vs 单池单合约PC-Fabric

![fabric-tps](.\img\fabric-tps.png)

相对而言，PC-Fabric比Fabric的最大TPS有所下降，但不超过3%。



#### 平均时延：Fabric vs 单池单合约PC-Fabric

![fabric-delay](.\img\fabric-delay.png)

PC-Fabric的平均时延长了0.01-0.02

为什么曲线图如此？由于在发送TPS从100到最大TPS（约800）过程中打出一个块的时间逐渐减少（按Fabric原打包策略，假如筹够400笔交易就打包一个块，那TPS=100时要等4s才开始打包，当TPS=800时只用半秒就打包），所以时延下降。但达到最大TPS后，由于系统不能再更多处理多余的交易就导致平均等待时间变长。



#### TPS：PC-Fabric 单池单合约 vs 三池单合约 vs 三池三合约

| 对照组             | 内容                                                         |
| ------------------ | ------------------------------------------------------------ |
| 单池单合约（1P1T） | 只安装一类合约cc1对应pool1，发送TPS都是调用cc1               |
| 三池单合约（3P1T） | 开了三个池pool1、pool2、pool3，三个池分别对应合约cc1、cc2、cc3，但发送TPS只调用cc1。假如TPS=300，每秒300笔cc1 |
| 三池三合约（3P3T） | 开了三个池pool1、pool2、pool3，三个池分别对应合约cc1、cc2、cc3，发送TPS轮流调用cc1、cc2、cc3。假如TPS=300，每秒cc1-3各100笔 |

![xPxT-pc-fabric-tps](.\img\xPxT-pc-fabric-tps.png)

对比1P1T和3P1T并不明显，会稍稍低一点点，在从1个池开到3个池的开销来说影响不大（交易到时发往一个池）

而3P3T明显下降了一些，最大TPS约有5%的下降



#### 平均时延：PC-Fabric 单池单合约 vs 三池单合约 vs 三池三合约

![xPxT-pc-fabric-delay](.\img\xPxT-pc-fabric-delay.png)

时延上来说1P1T和3P1T也是一样的，而3P3T由于发送TPS固定时，相比1P1T和3P1T，交易被均分到3个池子里，等待达到交易打包交易数的时间就延长了，所以平均时延变久。





#### TPS：PC-P3Chain 单池单合约 vs 三池单合约 vs 三池三合约

| 对照组     | 内容                                                         |
| ---------- | ------------------------------------------------------------ |
| 单池单合约 | 只安装一类合约DEMO1对应pool1，发送TPS都是调用DEMO1           |
| 三池单合约 | 开了三个池pool1、pool2、pool3，三个池分别对应合约DEMO1、DEMO2、DEMO3，但发送TPS只调用DEMO1。假如TPS=300，每秒300笔DEMO1 |
| 三池三合约 | 开了三个池pool1、pool2、pool3，三个池分别对应合约DEMO1、DEMO2、DEMO3，发送TPS轮流调用DEMO1、DEMO2、DEMO3。假如TPS=300，每秒DEMO1-3各100笔 |

![xPxT-pc-p3chain-tps](.\img\xPxT-pc-p3chain-tps.png)

和前面Fabric的解释一样。



#### 平均时延：PC-P3Chain 单池单合约 vs 三池单合约 vs 三池三合约

![xPxT-pc-p3chain-delay](.\img\xPxT-pc-p3chain-delay.png)

1P1T和3P1T的差别全然是由开多池的开销导致，而3P3T里由于定时时间一到，三个池都打包区块进行PBFT共识，相比于1P1T和3P1T，相同时间里产生的区块数就多2倍，而这些区块后续还要经过异步协调共识，由于此处的顺序进行，导致了3P3T的时延大大增加，增加了1.2s左右（1池到3池的变化下）



## 功能测试

### PC-Fabric

#### 无效性交易

| 测试设计       | 通过FILTER模块在共识之初进行交易无效性检查，排除黑名单之内的交易或只允许白名单之内的交易，提升交易有效率甚至TPS |
| -------------- | ------------------------------------------------------------ |
| 网络拓扑       | 2 peer、3orderer（raft）                                     |
| 交易类型和场景 | 单池合约cc1的set、get函数，只许白名单内成员进行set，不许黑名单内成员get。（上链的get和不上链get的重要区别在于，上链get过程记录在案）（类似于BGP的前缀宣告和检查，宣告只做set，检查只做get，只允许某些BGP做宣告，不允许某些恶意BGP做检查，当然私下检查当然可以。那为什么要弄上链的检查呢？通过宣告和检测的交易，我可以推理出网络的拓扑结构，而某些明确是恶意的BGP再做无中生有的检查时就会导致拓扑出错） |
| 测试内容       | TPS=800（接近最大TPS）下，随机对键为k的数据进行set或get，set k的值固定为v以保障交易不会因为冲突而失效。随机选择白名单之外的节点做set，随机选择黑名单之内的节点做get，这些节点指背书节点。 |
| 模块设计       | FILTER内针对交易的发起者进行黑白名单验证，首先会维持一张黑名单表和白名单表，假设名单是提前内嵌好的，当然想动态修改也是可以设计的，比如FILTER会从某个文件去读黑白名单，或者就是有一个专门的合约来更新黑白名单表。 |

> 不能用FILTER做冲突交易的过滤，交易是否冲突和FILTER后续的SELECT和ORDER等模块都有很大关系，不能提前知道是否冲突。

#### 冲突型交易

| 测试设计       | 对于区块内交易，利用ORDER将read-only型交易提前（甚至是配合SELECT将两批交易内的read-only型交易提取出来打在一个区块，其余的在下一个区块），提升交易有效率。 |
| -------------- | ------------------------------------------------------------ |
| 网络拓扑       | 2 peer、3orderer（raft）                                     |
| 交易类型和场景 | 单池合约cc1的set、get函数                                    |
| 测试内容       | TPS=800（接近最大TPS）下，随机对键为k1-k1000间的数据进行set或get，set k的值在一定范围内随机选取[1,10] |
| 模块设计       | 在ORDER模块内，将所有get类型的交易排在set交易前面。          |
| 设计的考虑     | 由于不断地发出交易，如果只是对某个key不停读写，且每次写入的值不一样，那在持续性地发送交易过程中，只有第一个块的get交易会因为select到块前头而有效，其他的get因为读到的key一直在变化而无论怎么排都无效。另外对于key的范围也要讲究，太窄会出现这种情况，一个还没上链的块内对某个key进行了一次set和一次get交易，但紧接着的一个块又对key进行set和get，这样一来下一个块的get就无效了。（set不会无效） |

#### 依赖型交易

| 测试设计       | 存在ABC三类交易，C的上链条件为AB先上链。通过SELECT和ORDER模块，提升C的上链成功率 |
| -------------- | ------------------------------------------------------------ |
| 网络拓扑       | 2 peer、3orderer（raft）                                     |
| 交易类型和场景 | 单池合约cc1的set函数，只有set An=1和set Bn=1两笔交易存在时，才会触发set Cn=1上链 |
| 测试内容       | TPS=800（接近最大TPS）下，不断轮流发送Tx-An、Tx-Bn、Tx-Cn，n属于正整数。 |
| 模块设计       | 设置SELECT只有当交易池里同时存在Tx-An、Tx-Bn、Tx-Cn三笔交易时，才一块将交易取出，并使用ORDER模块将三笔交易按需排列打包。 |
| 设计缘由       | 存在这种情况，假如甲乙双方对一份合同达成共识，各自发起A和B交易来表明自己赞同，而公证机构发起C来检验甲乙确实发起了AB并触发进一步的操作。在没有SELECT和ORDER的设计时，公证机构可能需要不断去检测链上是否有AB，才发起C，而现在就可以直接发出去就不管了，等AB出现了就自动触发。如果需要设置C的超时无效，即甲乙双方没有在一定时间内表明赞同，也是可以设计的。 |



#### 对照组

原Fabric，对标单池的PC-Fabric，无特殊的可编程功能。



### PC-P3Chain

#### 依赖型交易

测试设计：存在ABC三种交易，C的上链条件为AB先上链。通过SELECT和ORDER模块，提升C的上链成功率

#### 冲突型交易

测试设计：存在多笔交易（Set、Get两类）对某个key值进行读写操作（MID-PROCESS阶段）。通过SELECT+ORDER或MID-PROCESS模块设计，降低冲突导致的交易无效率

#### 互斥型交易

测试设计：提升正交交易的并行执行能力。通过SORT实现交易池间的交易都正交

#### 极差型交易

测试设计：存在两类交易，A：例如转账，单笔交易资源占用少、执行块，对交易确认时间要求高；B：例如股票交易，单笔交易存在较长时间（因为等待or计算复杂）。在交易内混杂着AB两类交易时，不能一次性混着将AB打包一块，导致A的确认时延被拉长。通过START和SELECT来降低A的交易确认时延。
